(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{605:function(t,e,s){"use strict";s.r(e);var v=s(17),l=Object(v.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"十-服务端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十-服务端渲染"}},[t._v("#")]),t._v(" 十.服务端渲染")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("前言")]),t._v(" "),s("p",[t._v("vue项目服务端渲染的场景，以及工具的选型与用法")])]),t._v(" "),s("p",[t._v("概念：放在浏览器进行就是浏览器渲染,放在服务器进行就是服务器渲染。")]),t._v(" "),s("ul",[s("li",[t._v("客户端渲染不利于 SEO 搜索引擎优化")]),t._v(" "),s("li",[t._v("服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的")]),t._v(" "),s("li",[t._v("SSR 直接将 HTML 字符串传递给浏览器。大大加快了首屏加载时间。")]),t._v(" "),s("li",[t._v("SSR 占用更多的 CPU 和内存资源")]),t._v(" "),s("li",[t._v("一些常用的浏览器 API 可能无法正常使用")]),t._v(" "),s("li",[t._v("在 vue 中只支持 beforeCreate 和 created 两个生命周期")]),t._v(" "),s("li",[t._v("Nuxt.js 是使用 Webpack 和 Node.js 进行封装的基于 Vue 的 SSR 框架")])])])}),[],!1,null,null,null);e.default=l.exports}}]);